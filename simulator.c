// simulator.c - Runs the bytecode generated by the assembler, line by line, executing the corresponding callback function for each instruction
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <math.h>
#include <assert.h>
#include "simulator.h"
#include "assembler.h"
#include "console.h"
#include "debugger.h"
#include "pause.h"

Instruction instrs[] = {
	/* name, op code, size of instruction, number of operands, callback function */
	{"irmovl", 0x30, 6, 2, irmovl_callback},
	{"rmmovl", 0x40, 6, 2, rmmovl_callback},
	{"mrmovl", 0x50, 6, 2, mrmovl_callback},
	{"rrmovl", 0x20, 2, 2, rrmovl_callback},
	{"rdint", 0xf2, 2, 1, rdint_callback},
	{"rdch", 0xf0, 2, 1, rdch_callback},
	{"wrint", 0xf3, 2, 1, wrint_callback},
	{"wrch", 0xf1, 2, 1, wrch_callback},
	{"nop", 0x00, 1, 0, nop_callback},
	{"halt", 0x10, 1, 0, halt_callback},
	{"jmp", 0x70, 5, 1, jmp_callback},
	{"addl", 0x60, 2, 2, addl_callback},
	{"subl", 0x61, 2, 2, subl_callback},
	{"xorl", 0x63, 2, 2, xorl_callback},
	{"andl", 0x62, 2, 2, andl_callback},
	{"multl", 0x64, 2, 2, multl_callback},
	{"divl", 0x65, 2, 2, divl_callback},
	{"modl", 0x66, 2, 2, modl_callback},
	{"je", 0x73, 5, 1, je_callback},
	{"jle", 0x71, 5, 1, jle_callback},
	{"jg", 0x76, 5, 1, jg_callback},
	{"jl", 0x72, 5, 1, jl_callback},
	{"jne", 0x74, 5, 1, jne_callback},
	{"jge", 0x75, 5, 1, jge_callback},
	{"pushl", 0xa0, 2, 1, pushl_callback},
	{"popl", 0xb0, 2, 1, popl_callback},
	{"call", 0x80, 5, 1, call_callback},
	{"ret", 0x90, 1, 0, ret_callback}
};

int num_instrs = sizeof(instrs) / sizeof(Instruction);

uint8 memory[4096];
int mem_len = 0;
uint32 registers[8];
Flags flgs;
StackFrame *stack_frames = NULL;
static uint16 PC = 0; // the program counter (instruction pointer)

// Initializes registers to 0
void sim_init_registers() {
	int i;
  
	for (i = 0; i <= 7; i++)
		registers[i] = 0;
}

// Initializes flags (condition codes) to 0
void sim_init_flags() {
	flgs.OF = 0;
	flgs.SF = 0;
	flgs.ZF = 0;
}

// Returns the program counter (instruction pointer)
uint16 sim_get_pc() {
	return PC;
}

// Sets the program counter
void sim_set_pc(uint16 new_PC) {
	PC = new_PC;
}

// Return 1 if reg_num is a valid register number and 0 if not
static int valid_reg_num(int reg_num) {
	return reg_num >= 0 && reg_num <= 7;
}

/*
  Pushes a new stack frame onto the stack of active function calls
  Called in call_callback for use by the backtrace command
*/
static void push_new_stack_frame(char *func_name, uint16 addr, uint32 esp) {
	StackFrame *frame;
  
	assert(func_name != NULL);
  
	frame = malloc(sizeof(StackFrame));

	if (frame != NULL) {
		strcpy(frame->func_name, func_name);
		frame->addr = addr;
		frame->esp = esp;

		// insert into the the head of linked list
		frame->next = stack_frames;
		stack_frames = frame;
	}
}

/*
  Pops the most recent stack frame from the stack of active function calls
  Called in ret_callback for use by the backtrace command
*/
static void pop_stack_frame() {
	StackFrame *old = stack_frames;
  
	if (stack_frames != NULL) {
		stack_frames = stack_frames->next;
		free(old);
	}
}

/* BYTE: 0x30 (opcode)
   BYTE: 4 high bits 8
   4 lower bits reg num
   UINT32: New value */
int irmovl_callback() {
	uint8 reg_num;
    
	reg_num = memory[PC+1] & 0x0F; // clear the 8 stored in 4 high bits
	if (!valid_reg_num(reg_num))
		return 0;
  
	registers[reg_num] = *((uint32*)&memory[PC+2]);
	DBG_PRINT("regnum = %d, new value: %08x\n", reg_num, registers[reg_num]); 
	PC += 6;
	return 1;
}

/* BYTE: 0x40 (opcode)
   BYTE: 4 higher bits source register number
   4 lower bits dest register number
   UINT32: Offset */
int rmmovl_callback() {
	uint32 offset;
	uint8 src_reg_num, dest_reg_num;
 
	src_reg_num = memory[PC+1] >> 4; // source
	dest_reg_num = memory[PC+1] & 0x0F; // destination
	offset = *((uint32*)&memory[PC+2]);

	DBG_PRINT("src_reg_num=%d, dest_reg_num=%d, offset=%x\n", src_reg_num, dest_reg_num, offset);
  
	if (!valid_reg_num(src_reg_num))
		return 0;

	if (dest_reg_num == 8) {
		/* dest_reg_num=8 signifies we are working with a raw memory address
		   (it was supplied as a label in the source), the actual address is stored in offset
		   so we want to move contents of src_num into the address stored in offset */
    
		if (offset > 4096-4) {
			write_to_dbg("rmmovl offset out of bounds");
			return 0;
		}
    
		*((uint32*)&memory[offset]) = registers[src_reg_num];
		DBG_PRINT("Wrote %x to address %x\n", registers[src_reg_num], offset);
	} else {
		uint32 addr = registers[dest_reg_num] + (int)offset;
    
		if (addr > 4096-4) {
			write_to_dbg("rmmovl offset out of bounds");
			return 0;
		}
    
		*((uint32*)&memory[addr]) = registers[src_reg_num];
		DBG_PRINT("Wrote %x to address %x\n", registers[src_reg_num], addr);
	}
  
	PC += 6;
	return 1;
}

/* BYTE: 0x50 (opcode)
   BYTE: 4 higher bits dest register number
   4 lower bits source register number
   UINT32: Offset */
int mrmovl_callback() {
	uint32 offset;
	uint8 src_reg_num, dest_reg_num;
    
	dest_reg_num = memory[PC+1] >> 4; // destination
	src_reg_num = memory[PC+1] & 0x0F; // source
	offset = *((uint32*)&memory[PC+2]);

	DBG_PRINT("dest_reg_num=%d, src_reg_num=%d, offset=%x\n", dest_reg_num, src_reg_num, offset);
  
	if (!valid_reg_num(dest_reg_num))
		return 0;
  
	if (src_reg_num == 8) {
		if (offset > 4096-4) {
			write_to_dbg("mrmovl offset out of bounds");
			return 0;
		}
    
		registers[dest_reg_num] = *((uint32*)&memory[offset]);
		DBG_PRINT("Read %x from address %x\n", registers[dest_reg_num], offset);
	} else {
		uint32 addr = registers[src_reg_num] + (int)offset;

		if (addr > 4096-4) {
			write_to_dbg("mrmovl offset out of bounds");
			return 0;
		}
    
		registers[dest_reg_num] =  *((uint32*)&memory[addr]);
		DBG_PRINT("Read %x from address %x\n", registers[dest_reg_num], addr);
	}
  
	PC += 6;
	return 1;
}

/* BYTE: 0x20 (opcode)
   BYTE: 4 higher bits source register number
   4 lower bits dest register number */
int rrmovl_callback() {
	uint32 src = memory[PC+1] >> 4;
	uint32 dest = memory[PC+1] & 0x0F;
    
	DBG_PRINT("src: %d, dest: %d\n", src, dest);
  
	if (!valid_reg_num(src) || !valid_reg_num(dest))
		return 0;
  
	registers[dest] = registers[src];
	PC += 2;
	return 1;
}

/* BYTE: 0xF2 (opcode)
   BYTE: 4 higher bits register number to read into
   4 lower bits 8 */
int rdint_callback() {
	uint8 reg_num = memory[PC+1] >> 4;
  
	if (!valid_reg_num(reg_num))
		return 0;
  
	set_window_title(sim, "(STATUS: Waiting for integer input - rdint)");
	read_from_win(sim, NULL, "%d", &registers[reg_num]);
	set_window_title(sim, NULL);

	DBG_PRINT("Read %d into reg num %d\n", registers[reg_num], reg_num);
  
	PC += 2;
	return 1;
}

/* BYTE: 0xF0 (opcode)
   BYTE: 4 higher bits register number to read into
   4 lower bits 8 */
int rdch_callback() {
	uint8 reg_num = memory[PC+1] >> 4;
 
	if (!valid_reg_num(reg_num))
		return 0;
  
	set_window_title(sim, "(STATUS: Waiting for character input - rdch)");
	read_from_win(sim, NULL, "%c", &registers[reg_num]);
	set_window_title(sim, NULL); 

	DBG_PRINT("Read %c into reg num %d\n", registers[reg_num], reg_num);
  
	PC += 2;
	return 1;
}

/* BYTE: 0xF3 (opcode)
   BYTE: 4 higher bits register number to read into
   4 lower bits 8 */
int wrint_callback() {
	uint8 reg_num = memory[PC+1] >> 4;
  
	if (!valid_reg_num(reg_num))
		return 0;
  
	write_to_sim("%d", registers[reg_num]);
	DBG_PRINT("Wrote %d to reg num %d\n", registers[reg_num], reg_num);
  
	PC += 2;
	return 1;
}

/* BYTE: 0xF1 (opcode)
   BYTE: 4 higher bits register number to read into
   4 lower bits 8 */
int wrch_callback() {
	uint8 reg_num = memory[PC+1] >> 4;
  
	if (!valid_reg_num(reg_num))
		return 0;

	write_to_sim("%c", registers[reg_num]);
	DBG_PRINT("Wrote %c to reg num %d\n", registers[reg_num], reg_num);
  
	PC += 2;
	return 1;
}

// BYTE: 0 (opcode)
int nop_callback() {
	PC++;
	return 1;
}

// BYTE: 0x10 (opcode)
int halt_callback() {
	DBG_PRINT("halt_callback()\n");
	get_key_and_exit();
	return 0;
}

/*
  Performs an arithmetical operation on 2 operands, the source and destination.
  Used by arithmetic instruction callbacks.
  Returns the result of the operation (i.e. new value of destination register)
  err will be set to 1 if an error occured and 0 if not, provided that err is not NULL
*/
uint32 do_arithmetic(uint32 src, uint32 dest, int op, int *err) {
	uint32 orig_dest;
  
	DBG_PRINT("src=%08x, dest=%08x\n", registers[src], registers[dest]);
  
	if (!valid_reg_num(src) || !valid_reg_num(dest)) {
		if (err != NULL)
			*err = 1; 
		return 0;
	}

	orig_dest = registers[dest];

	/*
	  this method for setting the OF flag is from http://www.c-jump.com/CIS77/ASM/Flags/F77_0110_overflow_flag.htm
	  it is adapted for 32 bit registers and seems to work fine
	*/
	if (op == ARITH_ADD) {
		registers[dest] += registers[src];
		flgs.OF = (signed)orig_dest > 0 && (signed)registers[src] > 0 && registers[dest] > 0x7FFFFFFF;
	}

	else if (op == ARITH_SUB) {
		registers[dest] -= registers[src];
		flgs.OF = (signed)orig_dest < 0 && (signed)registers[src] < 0 && (signed)registers[dest] < 0x7FFFFFFF; 
	}

	else if (op == ARITH_MULT) {
		registers[dest] *= registers[src];
		flgs.OF = (signed)orig_dest > 0 && (signed)registers[src] > 0 && registers[dest] > 0x7FFFFFFF;
	}

	else if (op == ARITH_DIV) {
		registers[dest] /= registers[src];
		flgs.OF = (signed)orig_dest > 0 && (signed)registers[src] > 0 && registers[dest] > 0x7FFFFFFF;
	}

	else if (op == ARITH_XOR) {
		registers[dest] ^= registers[src];
		flgs.OF = 0;
	}

	else if (op == ARITH_AND) {
		registers[dest] &= registers[src];
		flgs.OF = 0;
	}

	else if (op == ARITH_MOD) {
		registers[dest] %= registers[src];
		flgs.OF = 0;
	}

	else {
		if (err != NULL)
			*err = 1;
		DBG_PRINT("Invalid operation supplied\n");
		return 0;
	}

	DBG_PRINT("Result: %08x\n", registers[dest]);

	flgs.SF = (signed)registers[dest] < 0;
	flgs.ZF = registers[dest] == 0;

	if (flgs.OF)
		DBG_PRINT("Set OF flag\n");

	if (flgs.SF)
		DBG_PRINT("Set SF flag\n");

	if (flgs.ZF)
		DBG_PRINT("Set ZF flag\n");
   
	if (err != NULL)
		*err = 0;
  
	return registers[dest];
}

/* BYTE: 0x60 (opcode)
   BYTE: 4 higher bits source register number
   4 lower bits dest register number */
int addl_callback() {
	uint32 src = memory[PC+1] >> 4;
	uint32 dest = memory[PC+1] & 0x0F;
	int err;
  
	DBG_PRINT("src: %d, dest: %d\n", src, dest);
  
	if (!valid_reg_num(src) || !valid_reg_num(dest))
		return 0;
  
	do_arithmetic(src, dest, ARITH_ADD, &err);
  
	if (err)
		return 0;
  
	PC += 2;
	return 1;
}

/* BYTE: 0x61 (opcode)
   BYTE: 4 higher bits source register number
   4 lower bits dest register number */
int subl_callback() {
	uint32 src = memory[PC+1] >> 4;
	uint32 dest = memory[PC+1] & 0x0F;
	int err;
  
	DBG_PRINT("src: %d, dest: %d\n", src, dest);
  
	if (!valid_reg_num(src) || !valid_reg_num(dest))
		return 0;

	do_arithmetic(src, dest, ARITH_SUB, &err);

	if (err)
		return 0;
  
	PC += 2;
	return 1;
}

/* BYTE: 0x64 (opcode)
   BYTE: 4 higher bits source register number
   4 lower bits dest register number */
int multl_callback() {
	uint32 src = memory[PC+1] >> 4;
	uint32 dest = memory[PC+1] & 0x0F;
	int err;
  
	DBG_PRINT("src: %d, dest: %d\n", src, dest);
  
	if (!valid_reg_num(src) || !valid_reg_num(dest))
		return 0;

	do_arithmetic(src, dest, ARITH_MULT, &err);

	if (err)
		return 0;
  
	PC += 2;
	return 1;
}

/* BYTE: 0x65 (opcode)
   BYTE: 4 higher bits source register number
   4 lower bits dest register number */
int divl_callback() {
	uint32 src = memory[PC+1] >> 4;
	uint32 dest = memory[PC+1] & 0x0F;
	int err;
  
	DBG_PRINT("src: %d, dest: %d\n", src, dest);
  
	if (!valid_reg_num(src) || !valid_reg_num(dest))
		return 0;

	do_arithmetic(src, dest, ARITH_DIV, &err);

	if (err)
		return 0;
  
	PC += 2;
	return 1;
}

/* BYTE: 0x63 (opcode)
   BYTE: 4 higher bits source register number
   4 lower bits dest register number */
int xorl_callback() {
	uint32 src = memory[PC+1] >> 4;
	uint32 dest = memory[PC+1] & 0x0F;
	int err;
  
	DBG_PRINT("src: %d, dest: %d\n", src, dest);
  
	if (!valid_reg_num(src) || !valid_reg_num(dest))
		return 0;

	do_arithmetic(src, dest, ARITH_XOR, &err);

	if (err)
		return 0;
  
	PC += 2;
	return 1;
}

/* BYTE: 0x62 (opcode)
   BYTE: 4 higher bits source register number
   4 lower bits dest register number */
int andl_callback() {
	uint32 src = memory[PC+1] >> 4;
	uint32 dest = memory[PC+1] & 0x0F;
	int err;
  
	DBG_PRINT("src: %d, dest: %d\n", src, dest);
  
	if (!valid_reg_num(src) || !valid_reg_num(dest))
		return 0;

	do_arithmetic(src, dest, ARITH_AND, &err);

	if (err)
		return 0;
  
	PC += 2;
	return 1;
}

/* BYTE: 0x66 (opcode)
   BYTE: 4 higher bits source register number
   4 lower bits dest register number */
int modl_callback() {
	uint32 src = memory[PC+1] >> 4;
	uint32 dest = memory[PC+1] & 0x0F;
	int err;
  
	DBG_PRINT("src: %d, dest: %d\n", src, dest);
  
	if (!valid_reg_num(src) || !valid_reg_num(dest))
		return 0;

	do_arithmetic(src, dest, ARITH_MOD, &err);

	if (err)
		return 0;
  
	PC += 2;
	return 1;
}

/* BYTE: 0x70 (opcode)
   UINT32: jump address */
int jmp_callback() {
	PC = (int)*((uint32*)&memory[PC+1]);
	DBG_PRINT("To: %d\n", PC);
	return 1;
}

/* BYTE: 0x73 (opcode)
   UINT32: jump address */
int je_callback() {
	if (flgs.ZF) {
		PC = (int)*((uint32*)&memory[PC+1]);
		DBG_PRINT("Taking jump to %d\n", PC);
	} else {
		DBG_PRINT("Not taking jump to %d\n", (int)*((uint32*)&memory[PC+1]));
		PC += 5;
	}
  
	return 1;
}

/* BYTE: 0x71 (opcode)
   UINT32: jump address */
int jle_callback() {
	if ((flgs.SF ^ flgs.OF) | flgs.ZF) {
		PC = (int)*((uint32*)&memory[PC+1]);
		DBG_PRINT("Taking jump to %d\n", PC);
	} else {
		DBG_PRINT("Not taking jump to %d\n", (int)*((uint32*)&memory[PC+1]));
		PC += 5;
	}
  
	return 1;
}

/* BYTE: 0x76 (opcode)
   UINT32: jump address */
int jg_callback() {
	DBG_PRINT("SF=%d, OF=%d, ZF=%d\n", flgs.SF, flgs.OF, flgs.ZF);
  
	if (!(flgs.SF ^ flgs.OF) & !flgs.ZF) {
		PC = (int)*((uint32*)&memory[PC+1]);
		DBG_PRINT("Taking jump to %d\n", PC);
	} else {
		DBG_PRINT("Not taking jump to %d\n", (int)*((uint32*)&memory[PC+1]));
		PC += 5;
	}
  
	return 1;
}

/* BYTE: 0x72 (opcode)
   UINT32: jump address */
int jl_callback() {
	DBG_PRINT("SF=%d, OF=%d, ZF=%d\n", flgs.SF, flgs.OF, flgs.ZF);
  
	if (flgs.SF ^ flgs.OF) {
		PC = (int)*((uint32*)&memory[PC+1]);
		DBG_PRINT("Taking jump to %d\n", PC);
	} else {
		DBG_PRINT("Not taking jump to %d\n", (int)*((uint32*)&memory[PC+1]));
		PC += 5;
	}
  
	return 1;
}

/* BYTE: 0x74 (opcode)
   UINT32: jump address */
int jne_callback() {
	DBG_PRINT("SF=%d, OF=%d, ZF=%d\n", flgs.SF, flgs.OF, flgs.ZF);
  
	if (!flgs.ZF) {
		PC = (int)*((uint32*)&memory[PC+1]);
		DBG_PRINT("Taking jump to %d\n", PC);
	} else {
		DBG_PRINT("Not taking jump to %d\n", (int)*((uint32*)&memory[PC+1]));
		PC += 5;
	}
  
	return 1;
}

/* BYTE: 0x75 (opcode)
   UINT32: jump address */
int jge_callback() {
	DBG_PRINT("SF=%d, OF=%d, ZF=%d\n", flgs.SF, flgs.OF, flgs.ZF);
  
	if (!(flgs.SF ^ flgs.OF)) {
		PC = (int)*((uint32*)&memory[PC+1]);
		DBG_PRINT("Taking jump to %d\n", PC);
	} else {
		DBG_PRINT("Not taking jump to %d\n", (int)*((uint32*)&memory[PC+1]));
		PC += 5;
	}
  
	return 1;
}

/* Pushes a value onto the stack. If op is STACK_REG_VAL then src_reg is the register number
   of the register to push onto the stack. If op is STACK_RAW_VAL then val is the raw value
   to push onto the stack. If err is not NULL then the flag will be set to 1 if an error
   occured set to 0 if not. Returns the value pushed onto the stack */
uint32 pushl(uint8 src_reg, uint32 val, int op, int *err) {
	uint32 esp_val, push_val;
  
	if (op == STACK_REG_VAL) {
		if (!valid_reg_num(src_reg)) {
			if (err != NULL)
				*err = 1;
			return 0;
		}

		push_val = registers[src_reg];
	} else {
		push_val = val;
	}

	DBG_PRINT("Attempting to set push %d on stack\n", push_val);

	if (registers[ESP] > 4096) {
		write_to_dbg("Stack overflow");
		return 0;
	}
  
	registers[ESP] -= 4;
	esp_val = registers[ESP];
	*((uint32*)&memory[esp_val]) = push_val;
  
	if (err != NULL)
		*err = 0;

	return push_val;
}

/* Pops a value from the stack. If op is STACK_REG_VAL then dest_reg is the register number
   of the register to save the in. If op is STACK_RAW_VAL then the value will not be
   saved in a register. If err is not NULL then the flag will be set appropriately. Returns
   the value popped from the stack. */
uint32 popl(uint32 dest_reg, int op, int *err) {
	uint32 esp_val, deref_esp;

	if (registers[ESP] > 4096) {
		write_to_dbg("Stack overflow");
		return 0;
	}
  
	esp_val = registers[ESP];
	deref_esp = *((uint32*)&memory[esp_val]);
  
	if (op == STACK_REG_VAL) {
		if (!valid_reg_num(dest_reg)) {
			if (err != NULL)
				*err = 1;
      
			return 0;
		}
  
		registers[dest_reg] = deref_esp;
	}

	registers[ESP] += 4;

	if (err != NULL)
		*err = 0;

	DBG_PRINT("Popped %d from stack\n", deref_esp);
	return deref_esp;
}

/* BYTE: 0xA0 (opcode)
   BYTE: 4 higher bits register number to read into
   4 lower bits 8 */
int pushl_callback() {
	uint8 src_reg = memory[PC+1] >> 4;
	int err;
  
	if (!valid_reg_num(src_reg))
		return 0;

	pushl(src_reg, 0, STACK_REG_VAL, &err);

	if (err)
		return 0;
  
	PC += 2;
	return 1;
}

/* BYTE: 0xB0 (opcode)
   BYTE: 4 higher bits register number to read into
   4 lower bits 8 */
int popl_callback() {
	uint8 dest_reg;
	int err;
  
	dest_reg = memory[PC+1] >> 4;
  
	if (!valid_reg_num(dest_reg))
		return 0;
  
	popl(dest_reg, STACK_REG_VAL, &err);

	if (err)
		return 0;
  
	PC += 2;
	return 1;
}

/* BYTE: 0x80 (opcode)
   UINT32: function address */
int call_callback() {
	int err;
	uint32 call_addr;
	Label *func;

	pushl(0, PC+5, STACK_RAW_VAL, &err);

	if (err)
		return 0;

	call_addr = *((uint32*)&memory[PC+1]);
	func = find_label_by_addr(call_addr);

	if (func != NULL)
		push_new_stack_frame(func->name, func->addr, registers[ESP]);

	PC = call_addr;
	return 1;
}

// BYTE: 0x90 (opcode)
int ret_callback() {
	int err;
	PC = popl(0, STACK_RAW_VAL, &err);
	pop_stack_frame();
	return err == 0;
}

// Executes the byte code
void sim_exec_bytecode() {
	uint8 opcode;
	int i, found_callback;

	dbg_step = 1; // start off suspended, waiting for debugger input

	while (PC < 4096) {
		opcode = memory[PC];
		found_callback = 0;

		if (dbg_step >= 2)
			dbg_step--;
    
		if (dbg_suspend_check()) {
			dbg_step = 0;
			dbg_suspend_program();
		}
   
		// search for the correct command to process
		for (i = 0; i < num_instrs; i++) {      
			if (opcode == instrs[i].opcode) {
				found_callback = 1;
	
				if (!instrs[i].cmd_callback()) {
					write_to_dbg("%s callback failed, exiting...", instrs[i].name);
					get_key_and_exit();
				}
			}
		}

		if (!found_callback) {
			write_to_dbg("Could not find callback for opcode %x at PC=0x%x", opcode, PC);
			get_key_and_exit();
		}
	}

	get_key_and_exit();
}
